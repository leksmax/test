!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AR_FLAGS	Makefile	/^AR_FLAGS = rs$/;"	m
C_FLAGS	Makefile	/^C_FLAGS = -Wall -fPIC$/;"	m
DEPS	Makefile	/^DEPS = $(OBJS:%.o=%.d)$/;"	m
DNS_CNAME	net_tool.c	1142;"	d	file:
DNS_HOST	net_tool.c	1141;"	d	file:
FREE_PTR	net_tool.c	26;"	d	file:
INCS	Makefile	/^INCS = $(wildcard *.h)$/;"	m
INC_PATH	Makefile	/^INC_PATH = -I.$/;"	m
LD_FLAGS	Makefile	/^LD_FLAGS = -g$/;"	m
LD_LIBS	Makefile	/^LD_LIBS = -lm -lpthread -lz$/;"	m
LD_PATH	Makefile	/^LD_PATH = $/;"	m
MAX_ALLOC_LEN	net_tool.c	23;"	d	file:
OBJS	Makefile	/^OBJS = $(SRC:%.c=%.o)$/;"	m
PACKET_SIZE	net_tool.c	22;"	d	file:
RM	Makefile	/^RM = rm -f$/;"	m
ROUTE_FILE	net_tool.c	664;"	d	file:
SRC	Makefile	/^SRC = $(wildcard *.c)$/;"	m
TARGETS	Makefile	/^TARGETS = vpnctrl.cgi$/;"	m
VPNCTRL_MAX_TUNNELS	main.c	152;"	d	file:
VPNCTRL_SERVER_BASE	main.c	151;"	d	file:
_NET_TOOL_H_	net_tool.h	2;"	d
__anon1::buffer	cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
__anon1::length	cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
__anon1::offset	cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
a	cJSON.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
a	cJSON.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
a	cJSON.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
a	cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
add_one_route	net_tool.c	/^void add_one_route(struct route_info *one_route)$/;"	f	signature:(struct route_info *one_route)
addr	net_tool.c	/^				struct sockaddr_in addr;$/;"	l
addr	net_tool.c	/^	struct sockaddr addr;$/;"	l
addr	net_tool.c	/^	struct sockaddr_in addr;$/;"	l
addr_len	net_tool.c	/^	socklen_t addr_len = sizeof(struct sockaddr_in);$/;"	l
alias_array	net_tool.c	/^	cJSON *alias_array = cJSON_CreateArray();$/;"	l
aname	net_tool.c	/^	char cname[128] , aname[128] , ip[20];$/;"	l
answer	net_tool.c	/^    unsigned short answer=0;$/;"	l
answers	net_tool.c	/^	int n , i , flag , querys , answers;$/;"	l
array_count	net_tool.c	/^					int array_count = cJSON_GetArraySize(hosts);$/;"	l
array_count	net_tool.c	/^	int array_count = cJSON_GetArraySize(hosts);$/;"	l
bindir	Makefile	/^bindir ?= bin\/$/;"	m
bit	net_tool.c	/^		unsigned long bit = 1 << i;$/;"	l
buf	net_tool.c	/^	unsigned char buf[1024];$/;"	l
buf	net_tool.c	/^    char buf[20];$/;"	l
buffer	cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
c	cJSON.c	/^	cJSON *c=cJSON_New_Item();$/;"	l
c	cJSON.c	/^cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;$/;"	l
c	cJSON.c	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	l
c	cJSON.c	/^cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}$/;"	l
c	cJSON.c	/^cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}$/;"	l
c	cJSON.c	/^int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	l
c	cJSON.c	/^void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}$/;"	l
c	cJSON.c	/^void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}$/;"	l
c	cJSON.c	/^void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;$/;"	l
c	cJSON.c	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	l
cJSON	cJSON.h	/^typedef struct cJSON {$/;"	s
cJSON	cJSON.h	/^} cJSON;$/;"	t	typeref:struct:cJSON
cJSON::child	cJSON.h	/^	struct cJSON *child;		\/* An array or object item will have a child pointer pointing to a chain of the items in the array\/object. *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON	access:public
cJSON::next	cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON	access:public
cJSON::prev	cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::	access:public
cJSON::string	cJSON.h	/^	char *string;				\/* The item's name string, if this item is the child of, or is in the list of subitems of an object. *\/$/;"	m	struct:cJSON	access:public
cJSON::type	cJSON.h	/^	int type;					\/* The type of the item, as above. *\/$/;"	m	struct:cJSON	access:public
cJSON::valuedouble	cJSON.h	/^	double valuedouble;			\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON	access:public
cJSON::valueint	cJSON.h	/^	int valueint;				\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON	access:public
cJSON::valuestring	cJSON.h	/^	char *valuestring;			\/* The item's string, if type==cJSON_String *\/$/;"	m	struct:cJSON	access:public
cJSON_AddBoolToObject	cJSON.h	138;"	d
cJSON_AddFalseToObject	cJSON.h	137;"	d
cJSON_AddItemReferenceToArray	cJSON.c	/^void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}$/;"	f	signature:(cJSON *array, cJSON *item)
cJSON_AddItemReferenceToArray	cJSON.h	/^extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);$/;"	p	signature:(cJSON *array, cJSON *item)
cJSON_AddItemReferenceToObject	cJSON.c	/^void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}$/;"	f	signature:(cJSON *object,const char *string,cJSON *item)
cJSON_AddItemReferenceToObject	cJSON.h	/^extern void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);$/;"	p	signature:(cJSON *object,const char *string,cJSON *item)
cJSON_AddItemToArray	cJSON.c	/^void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}$/;"	f	signature:(cJSON *array, cJSON *item)
cJSON_AddItemToArray	cJSON.h	/^extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);$/;"	p	signature:(cJSON *array, cJSON *item)
cJSON_AddItemToObject	cJSON.c	/^void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}$/;"	f	signature:(cJSON *object,const char *string,cJSON *item)
cJSON_AddItemToObject	cJSON.h	/^extern void	cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);$/;"	p	signature:(cJSON *object,const char *string,cJSON *item)
cJSON_AddItemToObjectCS	cJSON.c	/^void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}$/;"	f	signature:(cJSON *object,const char *string,cJSON *item)
cJSON_AddItemToObjectCS	cJSON.h	/^extern void	cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item);	\/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object *\/$/;"	p	signature:(cJSON *object,const char *string,cJSON *item)
cJSON_AddNullToObject	cJSON.h	135;"	d
cJSON_AddNumberToObject	cJSON.h	139;"	d
cJSON_AddStringToObject	cJSON.h	140;"	d
cJSON_AddTrueToObject	cJSON.h	136;"	d
cJSON_Array	cJSON.h	37;"	d
cJSON_CreateArray	cJSON.c	/^cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}$/;"	f	signature:(void)
cJSON_CreateArray	cJSON.h	/^extern cJSON *cJSON_CreateArray(void);$/;"	p	signature:(void)
cJSON_CreateBool	cJSON.c	/^cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}$/;"	f	signature:(int b)
cJSON_CreateBool	cJSON.h	/^extern cJSON *cJSON_CreateBool(int b);$/;"	p	signature:(int b)
cJSON_CreateDoubleArray	cJSON.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const double *numbers,int count)
cJSON_CreateDoubleArray	cJSON.h	/^extern cJSON *cJSON_CreateDoubleArray(const double *numbers,int count);$/;"	p	signature:(const double *numbers,int count)
cJSON_CreateFalse	cJSON.c	/^cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}$/;"	f	signature:(void)
cJSON_CreateFalse	cJSON.h	/^extern cJSON *cJSON_CreateFalse(void);$/;"	p	signature:(void)
cJSON_CreateFloatArray	cJSON.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const float *numbers,int count)
cJSON_CreateFloatArray	cJSON.h	/^extern cJSON *cJSON_CreateFloatArray(const float *numbers,int count);$/;"	p	signature:(const float *numbers,int count)
cJSON_CreateIntArray	cJSON.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const int *numbers,int count)
cJSON_CreateIntArray	cJSON.h	/^extern cJSON *cJSON_CreateIntArray(const int *numbers,int count);$/;"	p	signature:(const int *numbers,int count)
cJSON_CreateNull	cJSON.c	/^cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}$/;"	f	signature:(void)
cJSON_CreateNull	cJSON.h	/^extern cJSON *cJSON_CreateNull(void);$/;"	p	signature:(void)
cJSON_CreateNumber	cJSON.c	/^cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}$/;"	f	signature:(double num)
cJSON_CreateNumber	cJSON.h	/^extern cJSON *cJSON_CreateNumber(double num);$/;"	p	signature:(double num)
cJSON_CreateObject	cJSON.c	/^cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}$/;"	f	signature:(void)
cJSON_CreateObject	cJSON.h	/^extern cJSON *cJSON_CreateObject(void);$/;"	p	signature:(void)
cJSON_CreateString	cJSON.c	/^cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}$/;"	f	signature:(const char *string)
cJSON_CreateString	cJSON.h	/^extern cJSON *cJSON_CreateString(const char *string);$/;"	p	signature:(const char *string)
cJSON_CreateStringArray	cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const char **strings,int count)
cJSON_CreateStringArray	cJSON.h	/^extern cJSON *cJSON_CreateStringArray(const char **strings,int count);$/;"	p	signature:(const char **strings,int count)
cJSON_CreateTrue	cJSON.c	/^cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}$/;"	f	signature:(void)
cJSON_CreateTrue	cJSON.h	/^extern cJSON *cJSON_CreateTrue(void);$/;"	p	signature:(void)
cJSON_Delete	cJSON.c	/^void cJSON_Delete(cJSON *c)$/;"	f	signature:(cJSON *c)
cJSON_Delete	cJSON.h	/^extern void   cJSON_Delete(cJSON *c);$/;"	p	signature:(cJSON *c)
cJSON_DeleteItemFromArray	cJSON.c	/^void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}$/;"	f	signature:(cJSON *array,int which)
cJSON_DeleteItemFromArray	cJSON.h	/^extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);$/;"	p	signature:(cJSON *array,int which)
cJSON_DeleteItemFromArray2	cJSON.c	/^void   cJSON_DeleteItemFromArray2(cJSON *array, cJSON *c)			{cJSON_Delete(cJSON_DetachItemFromArray2(array,c));}$/;"	f	signature:(cJSON *array, cJSON *c)
cJSON_DeleteItemFromArray2	cJSON.h	/^extern void   cJSON_DeleteItemFromArray2(cJSON *array, cJSON *c);$/;"	p	signature:(cJSON *array, cJSON *c)
cJSON_DeleteItemFromObject	cJSON.c	/^void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}$/;"	f	signature:(cJSON *object,const char *string)
cJSON_DeleteItemFromObject	cJSON.h	/^extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);$/;"	p	signature:(cJSON *object,const char *string)
cJSON_DetachItemFromArray	cJSON.c	/^cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;$/;"	f	signature:(cJSON *array,int which)
cJSON_DetachItemFromArray	cJSON.c	/^void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}$/;"	p	file:
cJSON_DetachItemFromArray	cJSON.h	/^extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);$/;"	p	signature:(cJSON *array,int which)
cJSON_DetachItemFromArray2	cJSON.c	/^cJSON *cJSON_DetachItemFromArray2(cJSON *array, cJSON *c)			{$/;"	f	signature:(cJSON *array, cJSON *c)
cJSON_DetachItemFromArray2	cJSON.c	/^void   cJSON_DeleteItemFromArray2(cJSON *array, cJSON *c)			{cJSON_Delete(cJSON_DetachItemFromArray2(array,c));}$/;"	p	file:
cJSON_DetachItemFromObject	cJSON.c	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	f	signature:(cJSON *object,const char *string)
cJSON_DetachItemFromObject	cJSON.c	/^void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}$/;"	p	file:
cJSON_DetachItemFromObject	cJSON.h	/^extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);$/;"	p	signature:(cJSON *object,const char *string)
cJSON_Duplicate	cJSON.c	/^cJSON *cJSON_Duplicate(cJSON *item,int recurse)$/;"	f	signature:(cJSON *item,int recurse)
cJSON_Duplicate	cJSON.h	/^extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);$/;"	p	signature:(cJSON *item,int recurse)
cJSON_False	cJSON.h	32;"	d
cJSON_GetArrayItem	cJSON.c	/^cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}$/;"	f	signature:(cJSON *array,int item)
cJSON_GetArrayItem	cJSON.h	/^extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);$/;"	p	signature:(cJSON *array,int item)
cJSON_GetArraySize	cJSON.c	/^int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	f	signature:(cJSON *array)
cJSON_GetArraySize	cJSON.h	/^extern int	  cJSON_GetArraySize(cJSON *array);$/;"	p	signature:(cJSON *array)
cJSON_GetErrorPtr	cJSON.c	/^const char *cJSON_GetErrorPtr(void) {return ep;}$/;"	f	signature:(void)
cJSON_GetErrorPtr	cJSON.h	/^extern const char *cJSON_GetErrorPtr(void);$/;"	p	signature:(void)
cJSON_GetObjectItem	cJSON.c	/^cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}$/;"	f	signature:(cJSON *object,const char *string)
cJSON_GetObjectItem	cJSON.h	/^extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);$/;"	p	signature:(cJSON *object,const char *string)
cJSON_Hooks	cJSON.h	/^typedef struct cJSON_Hooks {$/;"	s
cJSON_Hooks	cJSON.h	/^} cJSON_Hooks;$/;"	t	typeref:struct:cJSON_Hooks
cJSON_Hooks::free_fn	cJSON.h	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks	access:public
cJSON_Hooks::malloc_fn	cJSON.h	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks	access:public
cJSON_InitHooks	cJSON.c	/^void cJSON_InitHooks(cJSON_Hooks* hooks)$/;"	f	signature:(cJSON_Hooks* hooks)
cJSON_InitHooks	cJSON.h	/^extern void cJSON_InitHooks(cJSON_Hooks* hooks);$/;"	p	signature:(cJSON_Hooks* hooks)
cJSON_InsertItemInArray	cJSON.c	/^void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}$/;"	f	signature:(cJSON *array,int which,cJSON *newitem)
cJSON_InsertItemInArray	cJSON.h	/^extern void cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem);	\/* Shifts pre-existing items to the right. *\/$/;"	p	signature:(cJSON *array,int which,cJSON *newitem)
cJSON_IsReference	cJSON.h	40;"	d
cJSON_Minify	cJSON.c	/^void cJSON_Minify(char *json)$/;"	f	signature:(char *json)
cJSON_Minify	cJSON.h	/^extern void cJSON_Minify(char *json);$/;"	p	signature:(char *json)
cJSON_NULL	cJSON.h	34;"	d
cJSON_New_Item	cJSON.c	/^static cJSON *cJSON_New_Item(void)$/;"	f	file:	signature:(void)
cJSON_Number	cJSON.h	35;"	d
cJSON_Object	cJSON.h	38;"	d
cJSON_Parse	cJSON.c	/^cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}$/;"	f	signature:(const char *value)
cJSON_Parse	cJSON.h	/^extern cJSON *cJSON_Parse(const char *value);$/;"	p	signature:(const char *value)
cJSON_ParseWithOpts	cJSON.c	/^cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)$/;"	f	signature:(const char *value,const char **return_parse_end,int require_null_terminated)
cJSON_ParseWithOpts	cJSON.h	/^extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);$/;"	p	signature:(const char *value,const char **return_parse_end,int require_null_terminated)
cJSON_Print	cJSON.c	/^char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}$/;"	f	signature:(cJSON *item)
cJSON_Print	cJSON.h	/^extern char  *cJSON_Print(cJSON *item);$/;"	p	signature:(cJSON *item)
cJSON_PrintBuffered	cJSON.c	/^char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)$/;"	f	signature:(cJSON *item,int prebuffer,int fmt)
cJSON_PrintBuffered	cJSON.h	/^extern char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt);$/;"	p	signature:(cJSON *item,int prebuffer,int fmt)
cJSON_PrintUnformatted	cJSON.c	/^char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}$/;"	f	signature:(cJSON *item)
cJSON_PrintUnformatted	cJSON.h	/^extern char  *cJSON_PrintUnformatted(cJSON *item);$/;"	p	signature:(cJSON *item)
cJSON_ReplaceItemInArray	cJSON.c	/^void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;$/;"	f	signature:(cJSON *array,int which,cJSON *newitem)
cJSON_ReplaceItemInArray	cJSON.h	/^extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);$/;"	p	signature:(cJSON *array,int which,cJSON *newitem)
cJSON_ReplaceItemInObject	cJSON.c	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	f	signature:(cJSON *object,const char *string,cJSON *newitem)
cJSON_ReplaceItemInObject	cJSON.h	/^extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);$/;"	p	signature:(cJSON *object,const char *string,cJSON *newitem)
cJSON_SetIntValue	cJSON.h	143;"	d
cJSON_SetNumberValue	cJSON.h	144;"	d
cJSON_String	cJSON.h	36;"	d
cJSON_StringIsConst	cJSON.h	41;"	d
cJSON_True	cJSON.h	33;"	d
cJSON__h	cJSON.h	24;"	d
cJSON_free	cJSON.c	/^static void (*cJSON_free)(void *ptr) = free;$/;"	v	file:
cJSON_malloc	cJSON.c	/^static void *(*cJSON_malloc)(size_t sz) = malloc;$/;"	v	file:
cJSON_strcasecmp	cJSON.c	/^static int cJSON_strcasecmp(const char *s1,const char *s2)$/;"	f	file:	signature:(const char *s1,const char *s2)
cJSON_strdup	cJSON.c	/^static char* cJSON_strdup(const char* str)$/;"	f	file:	signature:(const char* str)
cal_chksum	net_tool.c	/^unsigned short cal_chksum(unsigned short *addr, int len)$/;"	f	signature:(unsigned short *addr, int len)
cal_time_interval	net_tool.c	/^double cal_time_interval(struct timeval *old_time, struct timeval *now_time)$/;"	f	signature:(struct timeval *old_time, struct timeval *now_time)
cgi_mode	main.c	/^int cgi_mode=1;$/;"	v
channel	main.c	/^				int channel = channel_item->valueint;$/;"	l
channel_item	main.c	/^			cJSON *channel_item = cJSON_GetObjectItem(req, "channel");$/;"	l
check_route_if	net_tool.c	/^int check_route_if(struct route_info *one_route, char *if_name)$/;"	f	signature:(struct route_info *one_route, char *if_name)
child	cJSON.c	/^	cJSON *child;$/;"	l
child	cJSON.c	/^	cJSON *child=item->child;$/;"	l
child	cJSON.h	/^	struct cJSON *child;		\/* An array or object item will have a child pointer pointing to a chain of the items in the array\/object. *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON	access:public
cname	net_tool.c	/^	char cname[128] , aname[128] , ip[20];$/;"	l
convert_subnet_to_string	net_tool.c	/^void convert_subnet_to_string(struct sockaddr *ip, struct sockaddr *mask, char *ret_buf)$/;"	f	signature:(struct sockaddr *ip, struct sockaddr *mask, char *ret_buf)
copy	cJSON.c	/^      char* copy;$/;"	l
cptr	cJSON.c	/^	cJSON *newitem,*cptr,*nptr=0,*newchild;$/;"	l
create_ping_socket	net_tool.c	/^int create_ping_socket()$/;"	f
create_reference	cJSON.c	/^static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}$/;"	f	file:	signature:(cJSON *item)
ctrl_response	main.c	/^	cJSON *ctrl_response = NULL;$/;"	l
cur	net_tool.c	/^	struct route_info *cur = first_route;$/;"	l
cur	net_tool.c	/^	struct route_info *cur = route;$/;"	l
d	cJSON.c	/^	double d=item->valuedouble;$/;"	l
datalen	net_tool.c	/^	int type , datalen , len;$/;"	l
decode_utf8_char	main.c	/^unsigned char decode_utf8_char(unsigned char *utf8)$/;"	f	signature:(unsigned char *utf8)
decode_utf8_str	main.c	/^unsigned char *decode_utf8_str(unsigned char *str)$/;"	f	signature:(unsigned char *str)
del_one_route	net_tool.c	/^void del_one_route(struct route_info *one_route)$/;"	f	signature:(struct route_info *one_route)
del_routes_by_if	net_tool.c	/^void del_routes_by_if(struct route_info *first_route, char *dev)$/;"	f	signature:(struct route_info *first_route, char *dev)
dest	net_tool.c	/^	struct sockaddr_in dest;$/;"	l
dst_buf	net_tool.c	/^	char dst_buf[20];$/;"	m	struct:route_info	file:	access:public
dump_JSON	main.c	/^void dump_JSON(cJSON *obj)$/;"	f	signature:(cJSON *obj)
dump_route	net_tool.c	/^void dump_route(struct route_info *route)$/;"	f	signature:(struct route_info *route)
dump_route_list	net_tool.c	/^void dump_route_list(struct route_info *first_route)$/;"	f	signature:(struct route_info *first_route)
end	cJSON.c	/^	const char *end=0;$/;"	l
end_time	net_tool.c	/^	struct timeval end_time;$/;"	l
endptr	net_tool.c	/^	char *endptr;$/;"	l
ensure	cJSON.c	/^static char* ensure(printbuffer *p,int needed)$/;"	f	file:	signature:(printbuffer *p,int needed)
entries	cJSON.c	/^	char **entries;$/;"	l
entries	cJSON.c	/^	char **entries=0,**names=0;$/;"	l
ep	cJSON.c	/^static const char *ep;$/;"	v	file:
fail	cJSON.c	/^	int numentries=0,fail=0;$/;"	l
fail	cJSON.c	/^	int numentries=0,i=0,fail=0;$/;"	l
fd	net_tool.c	/^	int fd = create_ping_socket();$/;"	l
file	net_tool.c	/^	FILE *file = fopen(ROUTE_FILE, "r");$/;"	l
firstByteMark	cJSON.c	/^static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
flag	cJSON.c	/^	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;$/;"	l
flag	net_tool.c	/^	int n , flag;$/;"	l
flag	net_tool.c	/^	int n , i , flag , querys , answers;$/;"	l
flags_buf	net_tool.c	/^	char flags_buf[20];$/;"	m	struct:route_info	file:	access:public
free_fn	cJSON.h	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks	access:public
free_route_list	net_tool.c	/^void free_route_list(struct route_info *first_route)$/;"	f	signature:(struct route_info *first_route)
from	net_tool.c	/^	struct sockaddr_in from;$/;"	l
fromlen	net_tool.c	/^						int fromlen = sizeof(from);$/;"	l
fromlen	net_tool.c	/^			int fromlen = sizeof(from);$/;"	l
generate_question	net_tool.c	/^generate_question(const char *dns_name , unsigned char *buf , int *len){$/;"	f	file:	signature:(const char *dns_name , unsigned char *buf , int *len)
generate_question	net_tool.c	/^generate_question(const char *dns_name$/;"	p	file:	signature:(const char *dns_name , unsigned char *buf , int *len)
get_char_from_utf8	main.c	/^unsigned char get_char_from_utf8(unsigned char *utf8)$/;"	f	signature:(unsigned char *utf8)
get_if_addr	net_tool.c	/^int get_if_addr(char *if_name, struct sockaddr *sock)$/;"	f	signature:(char *if_name, struct sockaddr *sock)
get_if_netmask	net_tool.c	/^int get_if_netmask(char *if_name, struct sockaddr *sock)$/;"	f	signature:(char *if_name, struct sockaddr *sock)
get_input	main.c	/^	char *get_input;$/;"	l
get_route_info	net_tool.c	/^void get_route_info(char *buf, struct route_info *one_route)$/;"	f	signature:(char *buf, struct route_info *one_route)
get_route_list	net_tool.c	/^struct route_info *get_route_list()$/;"	f
get_sockaddr	net_tool.c	/^struct sockaddr get_sockaddr(char *buf)$/;"	f	signature:(char *buf)
getcgidata	main.c	/^char* getcgidata(FILE* fp, char* requestmethod)$/;"	f	signature:(FILE* fp, char* requestmethod)
gw_buf	net_tool.c	/^	char gw_buf[20];$/;"	m	struct:route_info	file:	access:public
h	cJSON.c	/^	unsigned h=0;$/;"	l
he	net_tool.c	/^	struct hostent *he = gethostbyname(host);$/;"	l
he	net_tool.c	/^	struct hostent *he;    \/* structure that will get information about remote host *\/$/;"	l
head_buf	net_tool.c	/^	char head_buf[1000];$/;"	l
host_item	net_tool.c	/^							cJSON *host_item = cJSON_GetObjectItem(item, "ip");$/;"	l
host_item	net_tool.c	/^							cJSON *host_item = cJSON_GetObjectItem(item, ip_name);$/;"	l
host_item	net_tool.c	/^			cJSON *host_item = cJSON_GetObjectItem(itm, "ip");$/;"	l
host_item	net_tool.c	/^			cJSON *host_item = cJSON_GetObjectItem(itm, ip_name);$/;"	l
i	cJSON.c	/^	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;$/;"	l
i	cJSON.c	/^	int numentries=0,i=0,fail=0;$/;"	l
i	cJSON.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
i	cJSON.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
i	cJSON.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
i	cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
i	cJSON.c	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	l
i	cJSON.c	/^int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	l
i	cJSON.c	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	l
i	main.c	/^					int i;$/;"	l
i	main.c	/^		int i = 0, j = 0;$/;"	l
i	main.c	/^	int i = 0;$/;"	l
i	net_tool.c	/^					int i;$/;"	l
i	net_tool.c	/^			int i;$/;"	l
i	net_tool.c	/^		int i;$/;"	l
i	net_tool.c	/^	int i = 0;$/;"	l
i	net_tool.c	/^	int i;$/;"	l
i	net_tool.c	/^	int n , i , flag , querys , answers;$/;"	l
icmp	net_tool.c	/^				struct icmp *icmp;$/;"	l
icmp	net_tool.c	/^			struct icmp *icmp;$/;"	l
ifr	net_tool.c	/^	struct ifreq ifr;$/;"	l
in_if_addr	net_tool.c	/^		struct sockaddr_in *in_if_addr 	  = (struct sockaddr_in *)if_addr;$/;"	l
in_route_dst	net_tool.c	/^		struct sockaddr_in *in_route_dst  = (struct sockaddr_in *)&route_dst;$/;"	l
in_route_mask	net_tool.c	/^		struct sockaddr_in *in_route_mask = (struct sockaddr_in *)&route_mask;$/;"	l
input	main.c	/^	char *input = NULL;$/;"	l
input	main.c	/^	char* input;$/;"	l
interface_buf	net_tool.c	/^	char interface_buf[20];$/;"	m	struct:route_info	file:	access:public
interval_msec_dot	net_tool.c	/^    unsigned long long interval_msec_dot = 0;$/;"	l
interval_msec_int	net_tool.c	/^    unsigned long long interval_msec_int = 0;$/;"	l
into	cJSON.c	/^	char *into=json;$/;"	l
ip	net_tool.c	/^	char cname[128] , aname[128] , ip[20];$/;"	l
ip_addr	net_tool.c	/^	struct sockaddr ip_addr;$/;"	l
ip_array	net_tool.c	/^	cJSON *ip_array = cJSON_CreateArray();$/;"	l
iph	net_tool.c	/^				struct ip *iph;$/;"	l
iph	net_tool.c	/^			struct ip *iph;$/;"	l
ipv4_addr	net_tool.c	/^	struct sockaddr_in *ipv4_addr = (struct sockaddr_in *)&addr;$/;"	l
is_pointer	net_tool.c	/^is_pointer(int in);$/;"	p	file:	signature:(int in)
is_pointer	net_tool.c	/^static int is_pointer(int in){$/;"	f	file:	signature:(int in)
item	cJSON.c	/^cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}$/;"	l
item	cJSON.c	/^cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}$/;"	l
item	cJSON.c	/^cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}$/;"	l
item	cJSON.c	/^cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}$/;"	l
item	cJSON.c	/^cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}$/;"	l
item	cJSON.c	/^cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}$/;"	l
item	cJSON.c	/^cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}$/;"	l
item	cJSON.c	/^cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}$/;"	l
item	net_tool.c	/^						cJSON *item = cJSON_GetArrayItem(hosts, i);$/;"	l
item	net_tool.c	/^		cJSON *item = cJSON_GetArrayItem(hosts, j);$/;"	l
itm	net_tool.c	/^		cJSON *itm = cJSON_GetArrayItem(hosts, i);$/;"	l
j	cJSON.c	/^	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;$/;"	l
j	main.c	/^		int i = 0, j = 0;$/;"	l
j	net_tool.c	/^				int j;$/;"	l
j	net_tool.c	/^	int j;$/;"	l
latency_item	net_tool.c	/^									cJSON *latency_item = cJSON_GetObjectItem(item, "latency");$/;"	l
latency_item	net_tool.c	/^									cJSON *latency_item = cJSON_GetObjectItem(item, latency_name);$/;"	l
latency_item	net_tool.c	/^			cJSON *latency_item = cJSON_GetObjectItem(item, "latency");$/;"	l
latency_item	net_tool.c	/^			cJSON *latency_item = cJSON_GetObjectItem(item, latency_name);$/;"	l
len	cJSON.c	/^	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;$/;"	l
len	cJSON.c	/^	char *out=0,*ptr,*ret;int len=5;$/;"	l
len	cJSON.c	/^	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;$/;"	l
len	cJSON.c	/^	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;$/;"	l
len	cJSON.c	/^      size_t len;$/;"	l
len	main.c	/^	int len;$/;"	l
len	main.c	/^    int len = strlen((const char*)str);$/;"	l
len	net_tool.c	/^	int type , datalen , len;$/;"	l
length	cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
line_buf	net_tool.c	/^	char line_buf[1000];$/;"	l
main	main.c	/^int main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
malloc_fn	cJSON.h	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks	access:public
mask_addr	net_tool.c	/^	struct sockaddr mask_addr;$/;"	l
mask_buf	net_tool.c	/^	char mask_buf[20];$/;"	m	struct:route_info	file:	access:public
mask_in	net_tool.c	/^	struct sockaddr_in *mask_in = (struct sockaddr_in *)mask;$/;"	l
maxfds	net_tool.c	/^		int maxfds = sockfd + 1;$/;"	l
maxfds	net_tool.c	/^	int maxfds = 0;$/;"	l
metric_buf	net_tool.c	/^	char metric_buf[20];$/;"	m	struct:route_info	file:	access:public
mtu_buf	net_tool.c	/^	char mtu_buf[20];$/;"	m	struct:route_info	file:	access:public
my_dns_parse	net_tool.c	/^my_dns_parse(char *dns_server, char *dns_name);$/;"	p	file:	signature:(char *dns_server, char *dns_name)
my_dns_parse	net_tool.c	/^static cJSON *my_dns_parse(char *dns_server, char *dns_name) {$/;"	f	file:	signature:(char *dns_server, char *dns_name)
n	cJSON.c	/^	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;$/;"	l
n	cJSON.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
n	cJSON.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
n	cJSON.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
n	cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
n	net_tool.c	/^			int n;$/;"	l
n	net_tool.c	/^		int n = select(maxfds, &readfds, NULL, NULL, &timeo);$/;"	l
n	net_tool.c	/^	int n , flag;$/;"	l
n	net_tool.c	/^	int n , i , flag , querys , answers;$/;"	l
n	net_tool.c	/^	int n;$/;"	l
names	cJSON.c	/^	char **entries=0,**names=0;$/;"	l
net_tool_dns_request	net_tool.c	/^cJSON *net_tool_dns_request(char *dns_server, char *request_name)$/;"	f	signature:(char *dns_server, char *request_name)
net_tool_dns_request	net_tool.h	/^net_tool_dns_request(char *dns_server, char *request_name);$/;"	p	signature:(char *dns_server, char *request_name)
net_tool_get_if_addr	net_tool.c	/^int net_tool_get_if_addr(char *if_name, struct sockaddr *sock)$/;"	f	signature:(char *if_name, struct sockaddr *sock)
net_tool_get_if_addr	net_tool.h	/^net_tool_get_if_addr(char *if_name, struct sockaddr*);$/;"	p	signature:(char *if_name, struct sockaddr*)
net_tool_get_if_hwaddr	net_tool.c	/^int net_tool_get_if_hwaddr(char *if_name, char *buf)$/;"	f	signature:(char *if_name, char *buf)
net_tool_get_if_hwaddr	net_tool.h	/^net_tool_get_if_hwaddr(char *if_name, char *buf);$/;"	p	signature:(char *if_name, char *buf)
net_tool_get_if_ip	net_tool.c	/^int net_tool_get_if_ip(char *if_name, char *buf)$/;"	f	signature:(char *if_name, char *buf)
net_tool_get_if_ip	net_tool.h	/^net_tool_get_if_ip(char *if_name, char *buf);$/;"	p	signature:(char *if_name, char *buf)
net_tool_get_if_netmask	net_tool.c	/^int net_tool_get_if_netmask(char *if_name, char *buf)$/;"	f	signature:(char *if_name, char *buf)
net_tool_get_if_netmask	net_tool.h	/^net_tool_get_if_netmask(char *if_name, char *buf);$/;"	p	signature:(char *if_name, char *buf)
net_tool_get_if_subnet	net_tool.c	/^int net_tool_get_if_subnet(char *if_name, char *buf)$/;"	f	signature:(char *if_name, char *buf)
net_tool_get_if_subnet	net_tool.h	/^net_tool_get_if_subnet(char *if_name, char *buf);$/;"	p	signature:(char *if_name, char *buf)
net_tool_http_client	net_tool.c	/^char *net_tool_http_client(char *host, int port, char *uri, char *body, int *recv_len)$/;"	f	signature:(char *host, int port, char *uri, char *body, int *recv_len)
net_tool_http_client_raw	net_tool.c	/^char *net_tool_http_client_raw(char *host, int port, char *uri, void *body, int body_len, int *recv_len)$/;"	f	signature:(char *host, int port, char *uri, void *body, int body_len, int *recv_len)
net_tool_http_client_raw	net_tool.h	/^net_tool_http_client_raw(char *host, int port, char *uri, void *body, int body_len, int *recv_len);$/;"	p	signature:(char *host, int port, char *uri, void *body, int body_len, int *recv_len)
net_tool_http_json_client	net_tool.c	/^cJSON *net_tool_http_json_client(char *host, int port, char *uri, cJSON *req)$/;"	f	signature:(char *host, int port, char *uri, cJSON *req)
net_tool_http_json_client	net_tool.h	/^net_tool_http_json_client(char *host, int port, char *uri, cJSON *req);$/;"	p	signature:(char *host, int port, char *uri, cJSON *req)
net_tool_ping_host	net_tool.c	/^double net_tool_ping_host(const char* host, int timeout)$/;"	f	signature:(const char* host, int timeout)
net_tool_ping_host	net_tool.h	/^net_tool_ping_host(const char* host, int timeout);$/;"	p	signature:(const char* host, int timeout)
net_tool_ping_hosts	net_tool.c	/^void net_tool_ping_hosts(cJSON *hosts, int timeout)$/;"	f	signature:(cJSON *hosts, int timeout)
net_tool_ping_hosts	net_tool.h	/^net_tool_ping_hosts(cJSON* hosts, int timeout);$/;"	p	signature:(cJSON* hosts, int timeout)
net_tool_ping_hosts2	net_tool.c	/^void net_tool_ping_hosts2(cJSON *hosts, char *ip_name, char*latency_name, int timeout)$/;"	f	signature:(cJSON *hosts, char *ip_name, char*latency_name, int timeout)
net_tool_ping_hosts2	net_tool.h	/^net_tool_ping_hosts2(cJSON *hosts, char *ip_name, char*latency_name, int timeout);$/;"	p	signature:(cJSON *hosts, char *ip_name, char*latency_name, int timeout)
net_tool_reset_routes	net_tool.c	/^void net_tool_reset_routes(char *dev)$/;"	f	signature:(char *dev)
net_tool_reset_routes	net_tool.h	/^net_tool_reset_routes(char *dev);$/;"	p	signature:(char *dev)
net_tool_tcp_client	net_tool.c	/^char *net_tool_tcp_client(char *host, int port, char *send_buf, int send_len, int *recv_len)$/;"	f	signature:(char *host, int port, char *send_buf, int send_len, int *recv_len)
net_tool_tcp_client	net_tool.h	/^net_tool_tcp_client(char *host, int port, char *send_buf, int send_len, int *recv_len);$/;"	p	signature:(char *host, int port, char *send_buf, int send_len, int *recv_len)
net_tool_tcp_json_client	net_tool.c	/^cJSON *net_tool_tcp_json_client(char *host, int port, cJSON *req)$/;"	f	signature:(char *host, int port, cJSON *req)
net_tool_tcp_json_client	net_tool.h	/^net_tool_tcp_json_client(char *host, int port, cJSON *req);$/;"	p	signature:(char *host, int port, cJSON *req)
net_tool_tcp_json_client_with_size	net_tool.c	/^cJSON *net_tool_tcp_json_client_with_size(char *host, int port, cJSON *req, char *prefix, int prefix_size)$/;"	f	signature:(char *host, int port, cJSON *req, char *prefix, int prefix_size)
net_tool_tcp_json_client_with_size	net_tool.h	/^net_tool_tcp_json_client_with_size(char *host, int port, cJSON *req, char *prefix, int prefix_size);$/;"	p	signature:(char *host, int port, cJSON *req, char *prefix, int prefix_size)
netip	net_tool.c	/^	unsigned char netip[4];$/;"	l
network_part	net_tool.c	/^	struct sockaddr_in *network_part = (struct sockaddr_in *)ip;;$/;"	l
network_part_len	net_tool.c	/^	int network_part_len = 0;$/;"	l
network_part_len_buf	net_tool.c	/^	char network_part_len_buf[10];$/;"	l
new_item	cJSON.c	/^		cJSON *new_item;$/;"	l
newbuffer	cJSON.c	/^	char *newbuffer;int newsize;$/;"	l
newchild	cJSON.c	/^	cJSON *newitem,*cptr,*nptr=0,*newchild;$/;"	l
newitem	cJSON.c	/^	cJSON *newitem,*cptr,*nptr=0,*newchild;$/;"	l
newsize	cJSON.c	/^	char *newbuffer;int newsize;$/;"	l
next	cJSON.c	/^	cJSON *next;$/;"	l
next	cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON	access:public
next	net_tool.c	/^	struct route_info *next;$/;"	m	struct:route_info	typeref:struct:route_info::route_info	file:	access:public
nleft	net_tool.c	/^    int nleft=len;$/;"	l
node	cJSON.c	/^	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));$/;"	l
now_tv	net_tool.c	/^							struct timeval now_tv;$/;"	l
now_tv	net_tool.c	/^				struct timeval now_tv;$/;"	l
nptr	cJSON.c	/^	cJSON *newitem,*cptr,*nptr=0,*newchild;$/;"	l
number	net_tool.c	/^	long long int number = 0;$/;"	l
numentries	cJSON.c	/^	int numentries=0,fail=0;$/;"	l
numentries	cJSON.c	/^	int numentries=0,i=0,fail=0;$/;"	l
offset	cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
one_route	net_tool.c	/^			struct route_info *one_route = malloc(sizeof(struct route_info));$/;"	l
out	cJSON.c	/^	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;$/;"	l
out	cJSON.c	/^	char *out=0,*ptr,*ret;int len=5;$/;"	l
out	cJSON.c	/^	char *out=0;$/;"	l
out	cJSON.c	/^	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;$/;"	l
out	cJSON.c	/^	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;$/;"	l
output_json	main.c	/^void output_json(cJSON *obj)$/;"	f	signature:(cJSON *obj)
p	cJSON.c	/^	printbuffer p;$/;"	l
p	cJSON.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
p	cJSON.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
p	cJSON.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
p	cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	l
parse_array	cJSON.c	/^static const char *parse_array(cJSON *item,const char *value)$/;"	f	file:	signature:(cJSON *item,const char *value)
parse_array	cJSON.c	/^static const char *parse_array(cJSON *item,const char *value);$/;"	p	file:	signature:(cJSON *item,const char *value)
parse_dns_name	net_tool.c	/^parse_dns_name(unsigned char *chunk , unsigned char *ptr$/;"	p	file:	signature:(unsigned char *chunk , unsigned char *ptr , char *out , int *len)
parse_dns_name	net_tool.c	/^parse_dns_name(unsigned char *chunk$/;"	f	file:	signature:(unsigned char *chunk , unsigned char *ptr , char *out , int *len)
parse_dns_response	net_tool.c	/^parse_dns_response(int socketfd);$/;"	p	file:	signature:(int socketfd)
parse_dns_response	net_tool.c	/^static cJSON *parse_dns_response(int socketfd) {$/;"	f	file:	signature:(int socketfd)
parse_hex4	cJSON.c	/^static unsigned parse_hex4(const char *str)$/;"	f	file:	signature:(const char *str)
parse_number	cJSON.c	/^static const char *parse_number(cJSON *item,const char *num)$/;"	f	file:	signature:(cJSON *item,const char *num)
parse_object	cJSON.c	/^static const char *parse_object(cJSON *item,const char *value)$/;"	f	file:	signature:(cJSON *item,const char *value)
parse_object	cJSON.c	/^static const char *parse_object(cJSON *item,const char *value);$/;"	p	file:	signature:(cJSON *item,const char *value)
parse_string	cJSON.c	/^static const char *parse_string(cJSON *item,const char *str)$/;"	f	file:	signature:(cJSON *item,const char *str)
parse_value	cJSON.c	/^static const char *parse_value(cJSON *item,const char *value)$/;"	f	file:	signature:(cJSON *item,const char *value)
parse_value	cJSON.c	/^static const char *parse_value(cJSON *item,const char *value);$/;"	p	file:	signature:(cJSON *item,const char *value)
payload	main.c	/^    char *payload = cJSON_Print(obj);$/;"	l
pid	net_tool.c	/^				pid_t pid;$/;"	l
pid	net_tool.c	/^			pid_t pid;$/;"	l
pid	net_tool.c	/^	pid_t pid = getpid();$/;"	l
ping	net_tool.c	/^double ping(struct in_addr *dstip, int timeout)$/;"	f	signature:(struct in_addr *dstip, int timeout)
pkt_tv	net_tool.c	/^							struct timeval *pkt_tv;$/;"	l
pkt_tv	net_tool.c	/^				struct timeval *pkt_tv;$/;"	l
pos	net_tool.c	/^	char *pos = out + (*len);$/;"	l
pos	net_tool.c	/^	char *pos;$/;"	l
pow2gt	cJSON.c	/^static int pow2gt (int x)	{	--x;	x|=x>>1;	x|=x>>2;	x|=x>>4;	x|=x>>8;	x|=x>>16;	return x+1;	}$/;"	f	file:	signature:(int x)
prev	cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::	access:public
print_array	cJSON.c	/^static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:	signature:(cJSON *item,int depth,int fmt,printbuffer *p)
print_array	cJSON.c	/^static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);$/;"	p	file:	signature:(cJSON *item,int depth,int fmt,printbuffer *p)
print_number	cJSON.c	/^static char *print_number(cJSON *item,printbuffer *p)$/;"	f	file:	signature:(cJSON *item,printbuffer *p)
print_object	cJSON.c	/^static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:	signature:(cJSON *item,int depth,int fmt,printbuffer *p)
print_object	cJSON.c	/^static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);$/;"	p	file:	signature:(cJSON *item,int depth,int fmt,printbuffer *p)
print_string	cJSON.c	/^static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}$/;"	f	file:	signature:(cJSON *item,printbuffer *p)
print_string_ptr	cJSON.c	/^static char *print_string_ptr(const char *str,printbuffer *p)$/;"	f	file:	signature:(const char *str,printbuffer *p)
print_value	cJSON.c	/^static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:	signature:(cJSON *item,int depth,int fmt,printbuffer *p)
print_value	cJSON.c	/^static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);$/;"	p	file:	signature:(cJSON *item,int depth,int fmt,printbuffer *p)
printbuffer	cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	t	typeref:struct:__anon1	file:
ptr	cJSON.c	/^	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;$/;"	l
ptr	cJSON.c	/^	char *out=0,*ptr,*ret;int len=5;$/;"	l
ptr	cJSON.c	/^	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;$/;"	l
ptr	cJSON.c	/^	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;$/;"	l
ptr	net_tool.c	/^			char *ptr = strstr(response, "\\r\\n\\r\\n");$/;"	l
ptr	net_tool.c	/^	struct sockaddr_in *ptr = (struct sockaddr_in *)&ip_addr;$/;"	l
ptr	net_tool.c	/^	unsigned char *ptr = buf;$/;"	l
ptr	net_tool.c	/^	unsigned char *ptr = request;$/;"	l
ptr	net_tool.c	/^	unsigned char *ptr;$/;"	l
ptr2	cJSON.c	/^	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;$/;"	l
ptr2	cJSON.c	/^	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;$/;"	l
querys	net_tool.c	/^	int n , i , flag , querys , answers;$/;"	l
question	net_tool.c	/^	unsigned char question[128];$/;"	l
question_len	net_tool.c	/^	int question_len;$/;"	l
readfds	net_tool.c	/^	fd_set readfds;$/;"	l
recv_data	net_tool.c	/^char *recv_data(int sockfd, int *len)$/;"	f	signature:(int sockfd, int *len)
recv_len	net_tool.c	/^		int recv_len = 0;$/;"	l
recv_len	net_tool.c	/^	ssize_t recv_len = 0;$/;"	l
recv_len_total	net_tool.c	/^	ssize_t recv_len_total = 0;$/;"	l
recv_ping_packets	net_tool.c	/^void recv_ping_packets(int sockfd, cJSON *hosts, int timeout)$/;"	f	signature:(int sockfd, cJSON *hosts, int timeout)
recv_ping_packets2	net_tool.c	/^void recv_ping_packets2(int sockfd, cJSON *hosts, char *ip_name, char *latency_name, int timeout)$/;"	f	signature:(int sockfd, cJSON *hosts, char *ip_name, char *latency_name, int timeout)
recv_ptr	net_tool.c	/^	char *recv_ptr = NULL;$/;"	l
recvpacket	net_tool.c	/^			char recvpacket[PACKET_SIZE];$/;"	l
recvpacket	net_tool.c	/^	char recvpacket[PACKET_SIZE];$/;"	l
ref	cJSON.c	/^static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}$/;"	l
ref_buf	net_tool.c	/^	char ref_buf[20];$/;"	m	struct:route_info	file:	access:public
reload_config	main.c	/^	int	 reload_config = 0;$/;"	l
remain_len	main.c	/^			int remain_len = len;$/;"	l
req	main.c	/^		cJSON *req = cJSON_Parse(input);$/;"	l
req_method	main.c	/^	char *req_method = NULL;$/;"	l
request	net_tool.c	/^	unsigned char request[256];$/;"	l
response	net_tool.c	/^		char *response = net_tool_http_client(host, port, uri, str_req, &recv_len);$/;"	l
response	net_tool.c	/^		char *response = net_tool_tcp_client(host, port, send_buf, send_len + 4, &recv_len);$/;"	l
response	net_tool.c	/^		char *response = net_tool_tcp_client(host, port, str_req, strlen(str_req) + 1, &recv_len);$/;"	l
ret	cJSON.c	/^	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;$/;"	l
ret	cJSON.c	/^	char *out=0,*ptr,*ret;int len=5;$/;"	l
ret	main.c	/^	char *ret = NULL;$/;"	l
ret	main.c	/^    unsigned char ret = 0;$/;"	l
ret	main.c	/^    unsigned char ret = 0xff;$/;"	l
ret	net_tool.c	/^	cJSON *ret = NULL;$/;"	l
ret	net_tool.c	/^	char *ret = NULL;$/;"	l
ret	net_tool.c	/^	int ret = -1; $/;"	l
ret	net_tool.c	/^	int ret = -1;$/;"	l
ret	net_tool.c	/^	int ret = 0;$/;"	l
ret	net_tool.c	/^	int ret = net_tool_get_if_addr(dev, &addr);$/;"	l
ret	net_tool.c	/^	int ret;$/;"	l
ret	net_tool.c	/^	struct route_info *ret = NULL;$/;"	l
route_dst	net_tool.c	/^		struct sockaddr route_dst;$/;"	l
route_info	net_tool.c	/^struct route_info$/;"	s	file:
route_info::dst_buf	net_tool.c	/^	char dst_buf[20];$/;"	m	struct:route_info	file:	access:public
route_info::flags_buf	net_tool.c	/^	char flags_buf[20];$/;"	m	struct:route_info	file:	access:public
route_info::gw_buf	net_tool.c	/^	char gw_buf[20];$/;"	m	struct:route_info	file:	access:public
route_info::interface_buf	net_tool.c	/^	char interface_buf[20];$/;"	m	struct:route_info	file:	access:public
route_info::mask_buf	net_tool.c	/^	char mask_buf[20];$/;"	m	struct:route_info	file:	access:public
route_info::metric_buf	net_tool.c	/^	char metric_buf[20];$/;"	m	struct:route_info	file:	access:public
route_info::mtu_buf	net_tool.c	/^	char mtu_buf[20];$/;"	m	struct:route_info	file:	access:public
route_info::next	net_tool.c	/^	struct route_info *next;$/;"	m	struct:route_info	typeref:struct:route_info::route_info	file:	access:public
route_info::ref_buf	net_tool.c	/^	char ref_buf[20];$/;"	m	struct:route_info	file:	access:public
route_info::use_buf	net_tool.c	/^	char use_buf[20];$/;"	m	struct:route_info	file:	access:public
route_info::window_buf	net_tool.c	/^	char window_buf[20];$/;"	m	struct:route_info	file:	access:public
route_list	net_tool.c	/^	struct route_info *route_list = get_route_list();$/;"	l
route_mask	net_tool.c	/^		struct sockaddr route_mask;$/;"	l
route_need_delete	net_tool.c	/^int route_need_delete(struct route_info *one_route, char *if_name, struct sockaddr *if_addr)$/;"	f	signature:(struct route_info *one_route, char *if_name, struct sockaddr *if_addr)
rt	net_tool.c	/^	struct rtentry rt;$/;"	l
save_ptr1	net_tool.c	/^	char *save_ptr1 = NULL;$/;"	l
scale	cJSON.c	/^	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;$/;"	l
send_buf	net_tool.c	/^		char *send_buf = malloc(send_len + 4);$/;"	l
send_buf	net_tool.c	/^	char *send_buf = malloc(total_len);$/;"	l
send_data	net_tool.c	/^		char *send_data = send_buf + 4;$/;"	l
send_len	net_tool.c	/^		int send_len = prefix_size + strlen(str_req) + 1;$/;"	l
send_num	net_tool.c	/^	int send_num;$/;"	l
send_ping_packets	net_tool.c	/^void send_ping_packets(int fd, cJSON *hosts)$/;"	f	signature:(int fd, cJSON *hosts)
send_ping_packets2	net_tool.c	/^void send_ping_packets2(int fd, cJSON *hosts, char *ip_name)$/;"	f	signature:(int fd, cJSON *hosts, char *ip_name)
sendpacket	net_tool.c	/^				char sendpacket[PACKET_SIZE];$/;"	l
sendpacket	net_tool.c	/^			char sendpacket[PACKET_SIZE];$/;"	l
server	net_tool.c	/^	struct sockaddr_in server;$/;"	l
set_defaut_latency	net_tool.c	/^void set_defaut_latency(cJSON *hosts)$/;"	f	signature:(cJSON *hosts)
set_defaut_latency2	net_tool.c	/^void set_defaut_latency2(cJSON *hosts, char *latency_name)$/;"	f	signature:(cJSON *hosts, char *latency_name)
sign	cJSON.c	/^	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;$/;"	l
signsubscale	cJSON.c	/^	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;$/;"	l
sizeof	net_tool.c	/^					sendto(fd, (char *)&sendpacket, sizeof(struct icmp), 0, (struct sockaddr *)&addr, sizeof(addr));$/;"	p	file:
skip	cJSON.c	/^static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}$/;"	f	file:	signature:(const char *in)
socketfd	net_tool.c	/^	int socketfd = socket(AF_INET, SOCK_DGRAM, 0);$/;"	l
sockfd	net_tool.c	/^	int sockfd = socket(AF_INET, SOCK_DGRAM, 0); $/;"	l
sockfd	net_tool.c	/^	int sockfd = socket(AF_INET, SOCK_DGRAM, 0);$/;"	l
sockfd	net_tool.c	/^	int sockfd;$/;"	l
start_time	net_tool.c	/^	struct timeval start_time;$/;"	l
str	cJSON.c	/^	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;$/;"	l
str	cJSON.c	/^	char *str;$/;"	l
str	cJSON.c	/^	char *str=0;$/;"	l
str_req	net_tool.c	/^	char *str_req = cJSON_Print(req);$/;"	l
string	cJSON.h	/^	char *string;				\/* The item's name string, if this item is the child of, or is in the list of subitems of an object. *\/$/;"	m	struct:cJSON	access:public
subscale	cJSON.c	/^	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;$/;"	l
suffix_object	cJSON.c	/^static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}$/;"	f	file:	signature:(cJSON *prev,cJSON *item)
sum	net_tool.c	/^    int sum=0;$/;"	l
switch_input	main.c	/^    char *switch_input = NULL;$/;"	l
target_host	main.c	/^				char *target_host = "127.0.0.1";$/;"	l
target_host_item	main.c	/^				cJSON *target_host_item = cJSON_GetObjectItem(req, "target_host");$/;"	l
timeo	net_tool.c	/^		struct timeval timeo;$/;"	l
timeo	net_tool.c	/^	struct timeval timeo;$/;"	l
timeout	net_tool.c	/^		struct timeval timeout = {8, 0}; $/;"	l
tmp	main.c	/^			unsigned char tmp;$/;"	l
tmp	net_tool.c	/^		struct route_info *tmp = NULL;$/;"	l
tmp	net_tool.c	/^		struct route_info *tmp = cur;$/;"	l
tmp1	main.c	/^    unsigned char tmp1 = 0;$/;"	l
tmp2	main.c	/^    unsigned char tmp2 = 0;$/;"	l
tmp_str	main.c	/^    unsigned char *tmp_str = (unsigned char *)malloc(len + 1);$/;"	l
tmplen	cJSON.c	/^	size_t tmplen=0;$/;"	l
token	cJSON.c	/^	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;$/;"	l
token	net_tool.c	/^	char *token = NULL;$/;"	l
total_len	net_tool.c	/^	int total_len = strlen(head_buf) + body_len + 1;$/;"	l
total_len	net_tool.c	/^	int total_len = strlen(head_buf) + strlen(body) + 1;$/;"	l
tunnel_res	main.c	/^						cJSON* tunnel_res = net_tool_tcp_json_client_with_size(target_host, i + VPNCTRL_SERVER_BASE, req, "json", strlen("json"));$/;"	l
tval	net_tool.c	/^				struct timeval *tval= (struct timeval *)icmp->icmp_data;$/;"	l
tval	net_tool.c	/^	struct timeval *tval;$/;"	l
type	cJSON.h	/^	int type;					\/* The type of the item, as above. *\/$/;"	m	struct:cJSON	access:public
type	net_tool.c	/^	int type , datalen , len;$/;"	l
uc	cJSON.c	/^	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;$/;"	l
uc2	cJSON.c	/^	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;$/;"	l
update	cJSON.c	/^static int update(printbuffer *p)$/;"	f	file:	signature:(printbuffer *p)
use_buf	net_tool.c	/^	char use_buf[20];$/;"	m	struct:route_info	file:	access:public
used_time	net_tool.c	/^	double used_time = 0;$/;"	l
used_time	net_tool.c	/^	double used_time;$/;"	l
used_time	net_tool.c	/^    double used_time = 0;$/;"	l
valuedouble	cJSON.h	/^	double valuedouble;			\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON	access:public
valueint	cJSON.h	/^	int valueint;				\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON	access:public
valuestring	cJSON.h	/^	char *valuestring;			\/* The item's string, if type==cJSON_String *\/$/;"	m	struct:cJSON	access:public
w	net_tool.c	/^    unsigned short *w=addr;$/;"	l
web	net_tool.c	/^	char *web = NULL;$/;"	l
web_head	net_tool.c	/^	char *web_head = "POST %s HTTP\/1.1\\r\\n"$/;"	l
window_buf	net_tool.c	/^	char window_buf[20];$/;"	m	struct:route_info	file:	access:public
