--- a/compat/lib-rhashtable.c
+++ b/compat/lib-rhashtable.c
@@ -250,7 +250,11 @@ static struct bucket_table *bucket_table
 
 	INIT_LIST_HEAD(&tbl->walkers);
 
+#if LINUX_VERSION_IS_LESS(4,10,0)
+	get_random_bytes(&tbl->hash_rnd, sizeof(tbl->hash_rnd));
+#else
 	tbl->hash_rnd = get_random_u32();
+#endif
 
 	for (i = 0; i < nbuckets; i++)
 		INIT_RHT_NULLS_HEAD(tbl->buckets[i], ht, i);
--- a/backport-include/linux/skbuff.h
+++ b/backport-include/linux/skbuff.h
@@ -306,13 +306,6 @@ static inline void skb_free_frag(void *d
 	put_page(virt_to_head_page(data));
 }
 
-/* iwlwifi doesn't need this function, so it's safe to just return 0 */
-static inline
-__u32 skb_get_hash_perturb(const struct sk_buff *skb, u32 perturb)
-{
-	return 0;
-}
-
 #endif
 
 #if LINUX_VERSION_IS_LESS(4,13,0)
--- a/drivers/net/wireless/ath/ath10k/core.h
+++ b/drivers/net/wireless/ath/ath10k/core.h
@@ -544,7 +544,6 @@ struct ath10k_ce_crash_hdr {
 /* used for crash-dump storage, protected by data-lock */
 struct ath10k_fw_crash_data {
 	bool crashed_since_read;
-
 	guid_t guid;
 	struct timespec timestamp;
 	__le32 registers[REG_DUMP_COUNT_QCA988X];
--- a/drivers/net/wireless/ath/ath10k/pci.c
+++ b/drivers/net/wireless/ath/ath10k/pci.c
@@ -1479,7 +1479,6 @@ static void ath10k_pci_fw_crashed_dump(s
 	ath10k_err(ar, "firmware crashed! (guid %s)\n", guid);
 	ath10k_print_driver_info(ar);
 	ath10k_pci_dump_registers(ar, crash_data);
-	ath10k_ce_dump_registers(ar, crash_data);
 
 	spin_unlock_bh(&ar->data_lock);
 	ath10k_ce_dump_registers(ar);
--- a/drivers/net/wireless/ath/ath10k/ce.c
+++ b/drivers/net/wireless/ath/ath10k/ce.c
@@ -16,6 +16,7 @@
  */
 
 #include "hif.h"
+#include "pci.h"
 #include "ce.h"
 #include "debug.h"
 
@@ -1194,45 +1195,6 @@ void ath10k_ce_free_pipe(struct ath10k *
 	ce_state->dest_ring = NULL;
 }
 
-void ath10k_ce_dump_registers(struct ath10k *ar,
-			      struct ath10k_fw_crash_data *crash_data)
-{
-	struct ath10k_ce *ce = ath10k_ce_priv(ar);
-	struct ath10k_ce_crash_data ce_data;
-	u32 addr, id;
-
-	lockdep_assert_held(&ar->data_lock);
-
-	ath10k_err(ar, "Copy Engine register dump:\n");
-
-	spin_lock_bh(&ce->ce_lock);
-	for (id = 0; id < CE_COUNT; id++) {
-		addr = ath10k_ce_base_address(ar, id);
-		ce_data.base_addr = cpu_to_le32(addr);
-
-		ce_data.src_wr_idx =
-			cpu_to_le32(ath10k_ce_src_ring_write_index_get(ar, addr));
-		ce_data.src_r_idx =
-			cpu_to_le32(ath10k_ce_src_ring_read_index_get(ar, addr));
-		ce_data.dst_wr_idx =
-			cpu_to_le32(ath10k_ce_dest_ring_write_index_get(ar, addr));
-		ce_data.dst_r_idx =
-			cpu_to_le32(ath10k_ce_dest_ring_read_index_get(ar, addr));
-
-		if (crash_data)
-			crash_data->ce_crash_data[id] = ce_data;
-
-		ath10k_err(ar, "[%02d]: 0x%08x %3u %3u %3u %3u", id,
-			   le32_to_cpu(ce_data.base_addr),
-			   le32_to_cpu(ce_data.src_wr_idx),
-			   le32_to_cpu(ce_data.src_r_idx),
-			   le32_to_cpu(ce_data.dst_wr_idx),
-			   le32_to_cpu(ce_data.dst_r_idx));
-	}
-
-	spin_unlock_bh(&ce->ce_lock);
-}
-
 void ath10k_ce_dump_registers(struct ath10k *ar)
 {
 	struct ath10k_pci *ar_pci = ath10k_pci_priv(ar);
@@ -1249,7 +1211,7 @@ void ath10k_ce_dump_registers(struct ath
 
 	ath10k_err(ar, "Copy Engine register dump:\n");
 	ath10k_err(ar, "index: addr: sr_wr_idx: sr_r_idx: dst_wr_idx: dst_r_idx:\n");
-	spin_lock_bh(&ar_pci->ce_lock);
+	spin_lock_bh(&ar_pci->ce.ce_lock);
 
 	for (ce_id = 0; ce_id < CE_COUNT; ce_id++) {
 		addr = ath10k_ce_base_address(ar, ce_id);
@@ -1311,5 +1273,5 @@ void ath10k_ce_dump_registers(struct ath
 			break;
 	}
 
-	spin_unlock_bh(&ar_pci->ce_lock);
+	spin_unlock_bh(&ar_pci->ce.ce_lock);
 }
--- a/drivers/net/wireless/ath/ath10k/ce.h
+++ b/drivers/net/wireless/ath/ath10k/ce.h
@@ -244,8 +244,6 @@ void ath10k_ce_per_engine_service_any(st
 void ath10k_ce_per_engine_service(struct ath10k *ar, unsigned int ce_id);
 int ath10k_ce_disable_interrupts(struct ath10k *ar);
 void ath10k_ce_enable_interrupts(struct ath10k *ar);
-void ath10k_ce_dump_registers(struct ath10k *ar,
-			      struct ath10k_fw_crash_data *crash_data);
 
 /*==================CE debug====================*/
 #define CE_DESC_DUMP_COUNT	60
--- a/drivers/net/wireless/ath/ath10k/ahb.c
+++ b/drivers/net/wireless/ath/ath10k/ahb.c
@@ -197,40 +197,35 @@ static int ath10k_ahb_rst_ctrl_init(stru
 
 	dev = &ar_ahb->pdev->dev;
 
-	ar_ahb->core_cold_rst = devm_reset_control_get_exclusive(dev,
-								 "wifi_core_cold");
+	ar_ahb->core_cold_rst = devm_reset_control_get(dev, "wifi_core_cold");
 	if (IS_ERR(ar_ahb->core_cold_rst)) {
 		ath10k_err(ar, "failed to get core cold rst ctrl: %ld\n",
 			   PTR_ERR(ar_ahb->core_cold_rst));
 		return PTR_ERR(ar_ahb->core_cold_rst);
 	}
 
-	ar_ahb->radio_cold_rst = devm_reset_control_get_exclusive(dev,
-								  "wifi_radio_cold");
+	ar_ahb->radio_cold_rst = devm_reset_control_get(dev, "wifi_radio_cold");
 	if (IS_ERR(ar_ahb->radio_cold_rst)) {
 		ath10k_err(ar, "failed to get radio cold rst ctrl: %ld\n",
 			   PTR_ERR(ar_ahb->radio_cold_rst));
 		return PTR_ERR(ar_ahb->radio_cold_rst);
 	}
 
-	ar_ahb->radio_warm_rst = devm_reset_control_get_exclusive(dev,
-								  "wifi_radio_warm");
+	ar_ahb->radio_warm_rst = devm_reset_control_get(dev, "wifi_radio_warm");
 	if (IS_ERR(ar_ahb->radio_warm_rst)) {
 		ath10k_err(ar, "failed to get radio warm rst ctrl: %ld\n",
 			   PTR_ERR(ar_ahb->radio_warm_rst));
 		return PTR_ERR(ar_ahb->radio_warm_rst);
 	}
 
-	ar_ahb->radio_srif_rst = devm_reset_control_get_exclusive(dev,
-								  "wifi_radio_srif");
+	ar_ahb->radio_srif_rst = devm_reset_control_get(dev, "wifi_radio_srif");
 	if (IS_ERR(ar_ahb->radio_srif_rst)) {
 		ath10k_err(ar, "failed to get radio srif rst ctrl: %ld\n",
 			   PTR_ERR(ar_ahb->radio_srif_rst));
 		return PTR_ERR(ar_ahb->radio_srif_rst);
 	}
 
-	ar_ahb->cpu_init_rst = devm_reset_control_get_exclusive(dev,
-								"wifi_cpu_init");
+	ar_ahb->cpu_init_rst = devm_reset_control_get(dev, "wifi_cpu_init");
 	if (IS_ERR(ar_ahb->cpu_init_rst)) {
 		ath10k_err(ar, "failed to get cpu init rst ctrl: %ld\n",
 			   PTR_ERR(ar_ahb->cpu_init_rst));
--- a/net/mac80211/debugfs_sta.c
+++ b/net/mac80211/debugfs_sta.c
@@ -728,14 +728,14 @@ void ieee80211_rx_h_sta_stats(struct sta
 		return;
 
 	/* Not support 5Mhz and 10Mhz currently  */
-	if (status->flag & (RX_FLAG_5MHZ | RX_FLAG_10MHZ))
+	if (status->bw == RATE_INFO_BW_5 || status->bw == RATE_INFO_BW_10)
 		goto out;
 
-	if (status->vht_flag & RX_VHT_FLAG_160MHZ)
+	if (status->bw == RATE_INFO_BW_160)
 		bw_idx = 3;
-	else if (status->vht_flag & RX_VHT_FLAG_80MHZ)
+	else if (status->bw == RATE_INFO_BW_80)
 		bw_idx = 2;
-	else if (status->flag & RX_FLAG_40MHZ)
+	else if (status->bw == RATE_INFO_BW_40)
 		bw_idx = 1;
 	else
 		bw_idx = 0;
@@ -743,7 +743,7 @@ void ieee80211_rx_h_sta_stats(struct sta
 	i = abs(status->signal);
 	sta->sdata->vif.rx_signal_pkt[i]++;
 
-	if (status->flag & RX_FLAG_HT) {
+	if (status->encoding & RX_ENC_HT) {
 		mcs_idx = status->rate_idx;
 		nss_idx = mcs_idx >> 3;
 
@@ -757,9 +757,9 @@ void ieee80211_rx_h_sta_stats(struct sta
 		sta->rx_nss_byte[nss_idx] += pkt_len;
 		/* To fit into rate table for HT packets */
 		mcs_idx = mcs_idx % 8;
-	} else if (status->flag & RX_FLAG_VHT) {
+	} else if (status->encoding == RX_ENC_VHT) {
 		mcs_idx = status->rate_idx;
-		nss_idx = status->vht_nss - 1;
+		nss_idx = status->nss - 1;
 
 		if (nss_idx > IEEE80211_NSS_NUM - 1 ||
 		    mcs_idx > (IEEE80211_VHT_MCS_NUM - 1))
@@ -771,13 +771,13 @@ void ieee80211_rx_h_sta_stats(struct sta
 		sta->rx_nss_byte[nss_idx] += pkt_len;
 	}
 
-	gi_idx = (status->flag & RX_FLAG_SHORT_GI) ? 1 : 0;
+	gi_idx = (status->enc_flags & RX_ENC_FLAG_SHORT_GI) ? 1 : 0;
 	sta->rx_gi_pkt[gi_idx]++;
 	sta->rx_gi_byte[gi_idx] += pkt_len;
 	sta->rx_bw_pkt[bw_idx]++;
 	sta->rx_bw_byte[bw_idx] += pkt_len;
 
-	if (status->flag & (RX_FLAG_HT | RX_FLAG_VHT)) {
+	if (status->encoding == RX_ENC_HT || status->encoding == RX_ENC_VHT) {
 		/* Update Rate table for HT and VHT packets */
 		i = mcs_idx * 8 + 8 * 10 * nss_idx;
 		i += bw_idx * 2 + gi_idx;
@@ -786,14 +786,13 @@ void ieee80211_rx_h_sta_stats(struct sta
 	} else {
 		struct ieee80211_supported_band *sband;
 		struct ieee80211_sub_if_data *sdata = sta->sdata;
-		enum nl80211_band band = ieee80211_get_sdata_band(sdata);
 		int shift = ieee80211_vif_get_shift(&sta->sdata->vif);
 		u16 brate, legacy_rate;
 
 		if (status->rate_idx > IEEE80211_LEGACY_RATE_NUM - 1)
 			goto out;
 
-		sband = local->hw.wiphy->bands[band];
+		sband = ieee80211_get_sband(sdata);
 		brate = sband->bitrates[status->rate_idx].bitrate;
 		legacy_rate = DIV_ROUND_UP(brate, 1 << shift);
 		i = legacy_rate_to_index(legacy_rate);
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -1256,7 +1256,11 @@ static const struct net_device_ops ieee8
 	.ndo_set_rx_mode        = ieee80211_set_multicast_list,
 	.ndo_set_mac_address    = ieee80211_change_mac,
 	.ndo_select_queue       = ieee80211_netdev_select_queue,
-	.ndo_get_stats64        = ieee80211_get_stats64,
+#if LINUX_VERSION_IS_GEQ(4,11,0)
+        .ndo_get_stats64        = ieee80211_get_stats64,
+#else
+        .ndo_get_stats64 = bp_ieee80211_get_stats64,
+#endif
 };
 
 #if LINUX_VERSION_IS_GEQ(3,14,0) || \
--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
@@ -577,7 +577,7 @@ static void ar9003_hw_spur_mitigate_ofdm
 		if (AR_SREV_9531(ah)) {
 			spur_num = 2;
 			scale = 10; /* avoid floating calculate */
-			spurChansPtr = spur_freq_pri;
+			spurChansPtr = (void *)spur_freq_pri;
 		} else
 			spurChansPtr = &(eep->modalHeader2G.spurChans[0]);
 		mode = 1;
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -2561,8 +2561,7 @@ static int nl80211_send_iface(struct sk_
 
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
 	    nla_put_u32(msg, NL80211_ATTR_IFTYPE, wdev->iftype) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-			      NL80211_ATTR_PAD) ||
+	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)) ||
 	    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, wdev_address(wdev)) ||
 	    nla_put_u32(msg, NL80211_ATTR_GENERATION,
 			rdev->devlist_generation ^
@@ -4322,8 +4321,8 @@ static int nl80211_send_station(struct s
 	} while (0)
 #define PUT_SINFO_U64(attr, memb) do {					\
 	if (sinfo->filled & (1ULL << NL80211_STA_INFO_ ## attr) &&	\
-	    nla_put_u64_64bit(msg, NL80211_STA_INFO_ ## attr,		\
-			      sinfo->memb, NL80211_STA_INFO_PAD))	\
+	    nla_put_u64(msg, NL80211_STA_INFO_ ## attr,		\
+			      sinfo->memb))	\
 		goto nla_put_failure;					\
 	} while (0)
 
@@ -4446,8 +4445,8 @@ static int nl80211_send_station(struct s
 
 #define PUT_TIDVAL_U64(attr, memb) do {					\
 	if (tidstats->filled & BIT(NL80211_TID_STATS_ ## attr) &&	\
-	    nla_put_u64_64bit(msg, NL80211_TID_STATS_ ## attr,		\
-			      tidstats->memb, NL80211_TID_STATS_PAD))	\
+	    nla_put_u64(msg, NL80211_TID_STATS_ ## attr,		\
+			      tidstats->memb))	\
 		goto nla_put_failure;					\
 	} while (0)
 
@@ -7693,8 +7692,7 @@ static int nl80211_send_bss(struct sk_bu
 	if (wdev->netdev &&
 	    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex))
 		goto nla_put_failure;
-	if (nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-			      NL80211_ATTR_PAD))
+	if (nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)))
 		goto nla_put_failure;
 
 	bss = nla_nest_start(msg, NL80211_ATTR_BSS);
@@ -7715,8 +7713,7 @@ static int nl80211_send_bss(struct sk_bu
 	 */
 	ies = rcu_dereference(res->ies);
 	if (ies) {
-		if (nla_put_u64_64bit(msg, NL80211_BSS_TSF, ies->tsf,
-				      NL80211_BSS_PAD))
+		if (nla_put_u64(msg, NL80211_BSS_TSF, ies->tsf))
 			goto fail_unlock_rcu;
 		if (ies->len && nla_put(msg, NL80211_BSS_INFORMATION_ELEMENTS,
 					ies->len, ies->data))
@@ -7726,8 +7723,7 @@ static int nl80211_send_bss(struct sk_bu
 	/* and this pointer is always (unless driver didn't know) beacon data */
 	ies = rcu_dereference(res->beacon_ies);
 	if (ies && ies->from_beacon) {
-		if (nla_put_u64_64bit(msg, NL80211_BSS_BEACON_TSF, ies->tsf,
-				      NL80211_BSS_PAD))
+		if (nla_put_u64(msg, NL80211_BSS_BEACON_TSF, ies->tsf))
 			goto fail_unlock_rcu;
 		if (ies->len && nla_put(msg, NL80211_BSS_BEACON_IES,
 					ies->len, ies->data))
@@ -7746,15 +7742,13 @@ static int nl80211_send_bss(struct sk_bu
 		goto nla_put_failure;
 
 	if (intbss->parent_tsf &&
-	    (nla_put_u64_64bit(msg, NL80211_BSS_PARENT_TSF,
-			       intbss->parent_tsf, NL80211_BSS_PAD) ||
+	    (nla_put_u64(msg, NL80211_BSS_PARENT_TSF, intbss->parent_tsf) ||
 	     nla_put(msg, NL80211_BSS_PARENT_BSSID, ETH_ALEN,
 		     intbss->parent_bssid)))
 		goto nla_put_failure;
 
 	if (intbss->ts_boottime &&
-	    nla_put_u64_64bit(msg, NL80211_BSS_LAST_SEEN_BOOTTIME,
-			      intbss->ts_boottime, NL80211_BSS_PAD))
+	    nla_put_u64(msg, NL80211_BSS_LAST_SEEN_BOOTTIME, intbss->ts_boottime))
 		goto nla_put_failure;
 
 	switch (rdev->wiphy.signal_type) {
@@ -7879,28 +7873,28 @@ static int nl80211_send_survey(struct sk
 	    nla_put_flag(msg, NL80211_SURVEY_INFO_IN_USE))
 		goto nla_put_failure;
 	if ((survey->filled & SURVEY_INFO_TIME) &&
-	    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME,
-			survey->time, NL80211_SURVEY_INFO_PAD))
+	    nla_put_u64(msg, NL80211_SURVEY_INFO_TIME,
+			survey->time))
 		goto nla_put_failure;
 	if ((survey->filled & SURVEY_INFO_TIME_BUSY) &&
-	    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BUSY,
-			      survey->time_busy, NL80211_SURVEY_INFO_PAD))
+	    nla_put_u64(msg, NL80211_SURVEY_INFO_TIME_BUSY,
+			      survey->time_busy))
 		goto nla_put_failure;
 	if ((survey->filled & SURVEY_INFO_TIME_EXT_BUSY) &&
-	    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_EXT_BUSY,
-			      survey->time_ext_busy, NL80211_SURVEY_INFO_PAD))
+	    nla_put_u64(msg, NL80211_SURVEY_INFO_TIME_EXT_BUSY,
+			      survey->time_ext_busy))
 		goto nla_put_failure;
 	if ((survey->filled & SURVEY_INFO_TIME_RX) &&
-	    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_RX,
-			      survey->time_rx, NL80211_SURVEY_INFO_PAD))
+	    nla_put_u64(msg, NL80211_SURVEY_INFO_TIME_RX,
+			      survey->time_rx))
 		goto nla_put_failure;
 	if ((survey->filled & SURVEY_INFO_TIME_TX) &&
-	    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_TX,
-			      survey->time_tx, NL80211_SURVEY_INFO_PAD))
+	    nla_put_u64(msg, NL80211_SURVEY_INFO_TIME_TX,
+			      survey->time_tx))
 		goto nla_put_failure;
 	if ((survey->filled & SURVEY_INFO_TIME_SCAN) &&
-	    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_SCAN,
-			      survey->time_scan, NL80211_SURVEY_INFO_PAD))
+	    nla_put_u64(msg, NL80211_SURVEY_INFO_TIME_SCAN,
+			      survey->time_scan))
 		goto nla_put_failure;
 
 	nla_nest_end(msg, infoattr);
@@ -8659,8 +8653,7 @@ __cfg80211_alloc_vendor_skb(struct cfg80
 	}
 
 	if (wdev) {
-		if (nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,
-				      wdev_id(wdev), NL80211_ATTR_PAD))
+		if (nla_put_u64(skb, NL80211_ATTR_WDEV, wdev_id(wdev)))
 			goto nla_put_failure;
 		if (wdev->netdev &&
 		    nla_put_u32(skb, NL80211_ATTR_IFINDEX,
@@ -9360,8 +9353,7 @@ static int nl80211_remain_on_channel(str
 	if (err)
 		goto free_msg;
 
-	if (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,
-			      NL80211_ATTR_PAD))
+	if (nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie))
 		goto nla_put_failure;
 
 	genlmsg_end(msg, hdr);
@@ -9566,8 +9558,7 @@ static int nl80211_tx_mgmt(struct sk_buf
 		goto free_msg;
 
 	if (msg) {
-		if (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,
-				      NL80211_ATTR_PAD))
+		if (nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie))
 			goto nla_put_failure;
 
 		genlmsg_end(msg, hdr);
@@ -10996,8 +10987,7 @@ static int nl80211_probe_client(struct s
 	if (err)
 		goto free_msg;
 
-	if (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,
-			      NL80211_ATTR_PAD))
+	if (nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie))
 		goto nla_put_failure;
 
 	genlmsg_end(msg, hdr);
@@ -11414,8 +11404,7 @@ out:
 	}
 
 	/* propagate the instance id and cookie to userspace  */
-	if (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, func->cookie,
-			      NL80211_ATTR_PAD))
+	if (nla_put_u64(msg, NL80211_ATTR_COOKIE, func->cookie))
 		goto nla_put_failure;
 
 	func_attr = nla_nest_start(msg, NL80211_ATTR_NAN_FUNC);
@@ -11526,12 +11515,10 @@ void cfg80211_nan_match(struct wireless_
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
 	    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,
 					 wdev->netdev->ifindex)) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-			      NL80211_ATTR_PAD))
+	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)))
 		goto nla_put_failure;
 
-	if (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, match->cookie,
-			      NL80211_ATTR_PAD) ||
+	if (nla_put_u64(msg, NL80211_ATTR_COOKIE, match->cookie) ||
 	    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, match->addr))
 		goto nla_put_failure;
 
@@ -11606,12 +11593,10 @@ void cfg80211_nan_func_terminated(struct
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
 	    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,
 					 wdev->netdev->ifindex)) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-			      NL80211_ATTR_PAD))
+	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)))
 		goto nla_put_failure;
 
-	if (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,
-			      NL80211_ATTR_PAD))
+	if (nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie))
 		goto nla_put_failure;
 
 	func_attr = nla_nest_start(msg, NL80211_ATTR_NAN_FUNC);
@@ -11956,9 +11941,8 @@ static int nl80211_vendor_cmd_dump(struc
 			break;
 
 		if (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
-		    (wdev && nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,
-					       wdev_id(wdev),
-					       NL80211_ATTR_PAD))) {
+		    (wdev && nla_put_u64(skb, NL80211_ATTR_WDEV,
+					       wdev_id(wdev)))) {
 			genlmsg_cancel(skb, hdr);
 			break;
 		}
@@ -13353,8 +13337,8 @@ static int nl80211_add_scan_req(struct s
 		goto nla_put_failure;
 
 	if (req->info.scan_start_tsf &&
-	    (nla_put_u64_64bit(msg, NL80211_ATTR_SCAN_START_TIME_TSF,
-			       req->info.scan_start_tsf, NL80211_BSS_PAD) ||
+	    (nla_put_u64(msg, NL80211_ATTR_SCAN_START_TIME_TSF,
+			       req->info.scan_start_tsf) ||
 	     nla_put(msg, NL80211_ATTR_SCAN_START_TIME_TSF_BSSID, ETH_ALEN,
 		     req->info.tsf_bssid)))
 		goto nla_put_failure;
@@ -13379,8 +13363,7 @@ static int nl80211_prep_scan_msg(struct
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
 	    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,
 					 wdev->netdev->ifindex)) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-			      NL80211_ATTR_PAD))
+	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)))
 		goto nla_put_failure;
 
 	/* ignore errors and send incomplete event anyway */
@@ -14050,13 +14033,11 @@ static void nl80211_send_remain_on_chan_
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
 	    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,
 					 wdev->netdev->ifindex)) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-			      NL80211_ATTR_PAD) ||
+	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)) ||
 	    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, chan->center_freq) ||
 	    nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
 			NL80211_CHAN_NO_HT) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,
-			      NL80211_ATTR_PAD))
+	    nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie))
 		goto nla_put_failure;
 
 	if (cmd == NL80211_CMD_REMAIN_ON_CHANNEL &&
@@ -14290,8 +14271,7 @@ int nl80211_send_mgmt(struct cfg80211_re
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
 	    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,
 					netdev->ifindex)) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-			      NL80211_ATTR_PAD) ||
+	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)) ||
 	    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, freq) ||
 	    (sig_dbm &&
 	     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)) ||
@@ -14334,11 +14314,9 @@ void cfg80211_mgmt_tx_status(struct wire
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
 	    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,
 				   netdev->ifindex)) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-			      NL80211_ATTR_PAD) ||
+	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)) ||
 	    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,
-			      NL80211_ATTR_PAD) ||
+	    nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie) ||
 	    (ack && nla_put_flag(msg, NL80211_ATTR_ACK)))
 		goto nla_put_failure;
 
@@ -14733,8 +14711,7 @@ nl80211_radar_notify(struct cfg80211_reg
 		struct wireless_dev *wdev = netdev->ieee80211_ptr;
 
 		if (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||
-		    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-				      NL80211_ATTR_PAD))
+		    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)))
 			goto nla_put_failure;
 	}
 
@@ -14779,8 +14756,7 @@ void cfg80211_probe_status(struct net_de
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
 	    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||
 	    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,
-			      NL80211_ATTR_PAD) ||
+	    nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie) ||
 	    (acked && nla_put_flag(msg, NL80211_ATTR_ACK)))
 		goto nla_put_failure;
 
@@ -14925,8 +14901,7 @@ void cfg80211_report_wowlan_wakeup(struc
 		goto free_msg;
 
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-			      NL80211_ATTR_PAD))
+	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)))
 		goto free_msg;
 
 	if (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,
@@ -15189,8 +15164,7 @@ void cfg80211_crit_proto_stopped(struct
 		goto nla_put_failure;
 
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-			      NL80211_ATTR_PAD))
+	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)))
 		goto nla_put_failure;
 
 	genlmsg_end(msg, hdr);
@@ -15222,8 +15196,7 @@ void nl80211_send_ap_stopped(struct wire
 
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
 	    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex) ||
-	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
-			      NL80211_ATTR_PAD))
+	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)))
 		goto out;
 
 	genlmsg_end(msg, hdr);
--- a/compat/crypto-skcipher.c
+++ b/compat/crypto-skcipher.c
@@ -18,13 +18,9 @@
 #include <crypto/internal/skcipher.h>
 #include <crypto/scatterwalk.h>
 #include <linux/bug.h>
-#include <linux/cryptouser.h>
 #include <linux/compiler.h>
 #include <linux/list.h>
 #include <linux/module.h>
-#include <linux/rtnetlink.h>
-#include <linux/seq_file.h>
-#include <net/netlink.h>
 
 struct crypto_tfm *__crypto_alloc_tfm(struct crypto_alg *alg, u32 type,
 				      u32 mask);
@@ -593,11 +589,10 @@ static unsigned int crypto_skcipher_exts
 	if (alg->cra_type == &crypto_blkcipher_type)
 		return sizeof(struct crypto_blkcipher *);
 
-	if (alg->cra_type == &crypto_ablkcipher_type ||
-	    alg->cra_type == &crypto_givcipher_type)
-		return sizeof(struct crypto_ablkcipher *);
+	BUG_ON(alg->cra_type != &crypto_ablkcipher_type &&
+	       alg->cra_type != &crypto_givcipher_type);
 
-	return crypto_alg_extsize(alg);
+	return sizeof(struct crypto_ablkcipher *);
 }
 
 static int skcipher_setkey_blkcipher(struct crypto_skcipher *tfm,
@@ -823,119 +818,28 @@ static int skcipher_setkey(struct crypto
 	return cipher->setkey(tfm, key, keylen);
 }
 
-static void crypto_skcipher_exit_tfm(struct crypto_tfm *tfm)
-{
-	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
-	struct skcipher_alg *alg = crypto_skcipher_alg(skcipher);
-
-	alg->exit(skcipher);
-}
-
 static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)
 {
-	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
-	struct skcipher_alg *alg = crypto_skcipher_alg(skcipher);
 
 	if (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)
 		return crypto_init_skcipher_ops_blkcipher(tfm);
 
-	if (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||
-	    tfm->__crt_alg->cra_type == &crypto_givcipher_type)
-		return crypto_init_skcipher_ops_ablkcipher(tfm);
-
-	skcipher->setkey = skcipher_setkey;
-	skcipher->encrypt = alg->encrypt;
-	skcipher->decrypt = alg->decrypt;
-	skcipher->ivsize = alg->ivsize;
-	skcipher->keysize = alg->max_keysize;
-
-	if (alg->exit)
-		skcipher->base.exit = crypto_skcipher_exit_tfm;
-
-	if (alg->init)
-		return alg->init(skcipher);
-
-	return 0;
-}
+	BUG_ON(tfm->__crt_alg->cra_type != &crypto_ablkcipher_type &&
+	       tfm->__crt_alg->cra_type != &crypto_givcipher_type);
 
-static void crypto_skcipher_free_instance(struct crypto_instance *inst)
-{
-	struct skcipher_instance *skcipher =
-		container_of(inst, struct skcipher_instance, s.base);
-
-	skcipher->free(skcipher);
+	return crypto_init_skcipher_ops_ablkcipher(tfm);
 }
 
-static void crypto_skcipher_show(struct seq_file *m, struct crypto_alg *alg)
-	__maybe_unused;
-static void crypto_skcipher_show(struct seq_file *m, struct crypto_alg *alg)
-{
-	struct skcipher_alg *skcipher = container_of(alg, struct skcipher_alg,
-						     base);
-
-	seq_printf(m, "type         : skcipher\n");
-	seq_printf(m, "async        : %s\n",
-		   alg->cra_flags & CRYPTO_ALG_ASYNC ?  "yes" : "no");
-	seq_printf(m, "blocksize    : %u\n", alg->cra_blocksize);
-	seq_printf(m, "min keysize  : %u\n", skcipher->min_keysize);
-	seq_printf(m, "max keysize  : %u\n", skcipher->max_keysize);
-	seq_printf(m, "ivsize       : %u\n", skcipher->ivsize);
-	seq_printf(m, "chunksize    : %u\n", skcipher->chunksize);
-	seq_printf(m, "walksize     : %u\n", skcipher->walksize);
-}
-
-#ifdef CONFIG_NET
-static int crypto_skcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
-{
-	struct crypto_report_blkcipher rblkcipher;
-	struct skcipher_alg *skcipher = container_of(alg, struct skcipher_alg,
-						     base);
-
-	strncpy(rblkcipher.type, "skcipher", sizeof(rblkcipher.type));
-	strncpy(rblkcipher.geniv, "<none>", sizeof(rblkcipher.geniv));
-
-	rblkcipher.blocksize = alg->cra_blocksize;
-	rblkcipher.min_keysize = skcipher->min_keysize;
-	rblkcipher.max_keysize = skcipher->max_keysize;
-	rblkcipher.ivsize = skcipher->ivsize;
-
-	if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
-		    sizeof(struct crypto_report_blkcipher), &rblkcipher))
-		goto nla_put_failure;
-	return 0;
-
-nla_put_failure:
-	return -EMSGSIZE;
-}
-#else
-static int crypto_skcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
-{
-	return -ENOSYS;
-}
-#endif
-
 static const struct crypto_type crypto_skcipher_type2 = {
 	.extsize = crypto_skcipher_extsize,
 	.init_tfm = crypto_skcipher_init_tfm,
-	.free = crypto_skcipher_free_instance,
-#ifdef CONFIG_PROC_FS
-	.show = crypto_skcipher_show,
-#endif
 	.report = crypto_skcipher_report,
 	.maskclear = ~CRYPTO_ALG_TYPE_MASK,
 	.maskset = CRYPTO_ALG_TYPE_BLKCIPHER_MASK,
-	.type = CRYPTO_ALG_TYPE_SKCIPHER,
+	.type = CRYPTO_ALG_TYPE_BLKCIPHER,
 	.tfmsize = offsetof(struct crypto_skcipher, base),
 };
 
-int crypto_grab_skcipher(struct crypto_skcipher_spawn *spawn,
-			  const char *name, u32 type, u32 mask)
-{
-	spawn->base.frontend = &crypto_skcipher_type2;
-	return crypto_grab_spawn(&spawn->base, name, type, mask);
-}
-EXPORT_SYMBOL_GPL(crypto_grab_skcipher);
-
 struct crypto_skcipher *crypto_alloc_skcipher(const char *alg_name,
 					      u32 type, u32 mask)
 {
@@ -943,93 +847,5 @@ struct crypto_skcipher *crypto_alloc_skc
 }
 EXPORT_SYMBOL_GPL(crypto_alloc_skcipher);
 
-int crypto_has_skcipher2(const char *alg_name, u32 type, u32 mask)
-{
-	return crypto_type_has_alg(alg_name, &crypto_skcipher_type2,
-				   type, mask);
-}
-EXPORT_SYMBOL_GPL(crypto_has_skcipher2);
-
-static int skcipher_prepare_alg(struct skcipher_alg *alg)
-{
-	struct crypto_alg *base = &alg->base;
-
-	if (alg->ivsize > PAGE_SIZE / 8 || alg->chunksize > PAGE_SIZE / 8 ||
-	    alg->walksize > PAGE_SIZE / 8)
-		return -EINVAL;
-
-	if (!alg->chunksize)
-		alg->chunksize = base->cra_blocksize;
-	if (!alg->walksize)
-		alg->walksize = alg->chunksize;
-
-	base->cra_type = &crypto_skcipher_type2;
-	base->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;
-	base->cra_flags |= CRYPTO_ALG_TYPE_SKCIPHER;
-
-	return 0;
-}
-
-int crypto_register_skcipher(struct skcipher_alg *alg)
-{
-	struct crypto_alg *base = &alg->base;
-	int err;
-
-	err = skcipher_prepare_alg(alg);
-	if (err)
-		return err;
-
-	return crypto_register_alg(base);
-}
-EXPORT_SYMBOL_GPL(crypto_register_skcipher);
-
-void crypto_unregister_skcipher(struct skcipher_alg *alg)
-{
-	crypto_unregister_alg(&alg->base);
-}
-EXPORT_SYMBOL_GPL(crypto_unregister_skcipher);
-
-int crypto_register_skciphers(struct skcipher_alg *algs, int count)
-{
-	int i, ret;
-
-	for (i = 0; i < count; i++) {
-		ret = crypto_register_skcipher(&algs[i]);
-		if (ret)
-			goto err;
-	}
-
-	return 0;
-
-err:
-	for (--i; i >= 0; --i)
-		crypto_unregister_skcipher(&algs[i]);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(crypto_register_skciphers);
-
-void crypto_unregister_skciphers(struct skcipher_alg *algs, int count)
-{
-	int i;
-
-	for (i = count - 1; i >= 0; --i)
-		crypto_unregister_skcipher(&algs[i]);
-}
-EXPORT_SYMBOL_GPL(crypto_unregister_skciphers);
-
-int skcipher_register_instance(struct crypto_template *tmpl,
-			   struct skcipher_instance *inst)
-{
-	int err;
-
-	err = skcipher_prepare_alg(&inst->alg);
-	if (err)
-		return err;
-
-	return crypto_register_instance(tmpl, skcipher_crypto_instance(inst));
-}
-EXPORT_SYMBOL_GPL(skcipher_register_instance);
-
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Symmetric key cipher type");
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -8079,6 +8079,8 @@ struct ath10k_vif *ath10k_get_arvif(stru
 	return arvif_iter.arvif;
 }
 
+#ifdef CONFIG_ACPI
+
 #define WRD_METHOD "WRDD"
 #define WRDD_WIFI  (0x07)
 
@@ -8165,6 +8167,13 @@ static int ath10k_mac_get_wrdd_regulator
 	*rd |= COUNTRY_ERD_FLAG;
 	return 0;
 }
+#else
+static int ath10k_mac_get_wrdd_regulatory(struct ath10k *ar, u16 *rd)
+{
+	/* Use EEPROM regulatory information when ACPI is not being used */
+	return -1;
+}
+#endif /* CONFIG_ACPI */
 
 static int ath10k_mac_init_rd(struct ath10k *ar)
 {
--- a/include/linux/rhashtable.h
+++ b/include/linux/rhashtable.h
@@ -1,5 +1,5 @@
 /* Automatically created during backport process */
-#ifndef CPTCFG_BPAUTO_RHASHTABLE
+#if !defined(CPTCFG_BPAUTO_RHASHTABLE) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,0))
 #include_next <linux/rhashtable.h>
 #else
 #undef lockdep_rht_mutex_is_held
--- a/net/mac80211/status.c
+++ b/net/mac80211/status.c
@@ -926,6 +926,7 @@ void ieee80211_tx_status_ext(struct ieee
 	struct ieee80211_supported_band *sband;
 	int retry_count;
 	bool acked, noack_success;
+	int rates_idx;
 
 	if (status->skb)
 		return __ieee80211_tx_status(hw, status);
--- a/net/wireless/Makefile
+++ b/net/wireless/Makefile
@@ -19,6 +19,6 @@ cfg80211-$(CPTCFG_CFG80211_INTERNAL_REGD
 CFLAGS_trace.o := -I$(src)
 
 $(obj)/regdb.c: $(src)/db.txt $(src)/genregdb.awk
-	@$(AWK) -f $(backport_srctree)/$(src)/genregdb.awk < $< > $@
+	@$(AWK) -f $(src)/genregdb.awk < $< > $@
 
 clean-files := regdb.c
